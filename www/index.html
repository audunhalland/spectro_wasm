<head>
  <title>WebAssembly Spectro</title>
</head>
<body>
  <script>
    const scriptName = 'spectro2';
    // Need this global variable, which is stupid.
    var Module = {};

    function load_spectro2() {
      return fetch(`${scriptName}.wasm`)
        .then(response => response.arrayBuffer())
        .then(buffer => {
          Module.wasmBinary = buffer;

          return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = `${scriptName}.js`;
            document.body.appendChild(script);
            script.onload = () => {
              console.log(`${scriptName} loaded!`);
              console.log('analyze function: ', Module._analyze);
              resolve(Module);
            };
          });
        });
    }

    function test_memory() {
      const ptr = Module._malloc(4);
      Module.HEAPU32[ptr>>2] = 41;
      const result = Module._add_one(ptr);
      console.log('ptr=%s, result=%s', ptr, result);
      //wm._free(ptr);
    }

    Promise.all([load_spectro2(), navigator.mediaDevices.getUserMedia({ audio: true })])
      .then(([wm, stream]) => {
        const bufsize = 2048;
        const ctx = new AudioContext();
        const source = ctx.createMediaStreamSource(stream);
        const processor = ctx.createScriptProcessor(bufsize, 2, 2);

        test_memory();

        // "native" sample memory
        const buf = wm._malloc(bufsize * 4);

        processor.onaudioprocess = (event) => {
          // left channel only...
          const jsData = event.inputBuffer.getChannelData(0);

          // "memcpy" data into wasm mem pool
          wm.HEAPF32.set(jsData, buf / 4);

          // Call into wasm
          wm._analyze(buf, bufsize);
        };

        source.connect(processor);
        processor.connect(ctx.destination);
      }).catch(err => {
        console.log('error! ', err);
      });
  </script>
</head>
  WebAssembly Spectro!
</body>
